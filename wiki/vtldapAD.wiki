#labels java,jndi,activedirectory,ldap
#sidebar vtldapSidebar

<wiki:toc max_depth="2" />

= Windows Active Directory =
Active Directory provides an LDAPv3 compliant interface for performing operations. However, users should be aware of several pitfalls that are unique to Active Directory. This document attempts to explain these pitfalls and how to overcome them when using the vt-ldap library.

== Referrals ==
JNDI provides three ways in which to handle LDAP referrals: 'ignore', 'follow', and 'throw'. The way in which you configure this setting will determine how your search operations behave. Note that Active Directory will typically use referrals for any search bases that access domain DNS objects at the root level. e.g. dc=mydomain,dc=org.

=== Ignoring Referrals ===
Set the property: _edu.vt.middleware.ldap.referral=ignore_<br/>
The is the default setting, if you don't specify a value this is the behavior you will experience. Using this value causes JNDI to invoke the [http://www.faqs.org/rfcs/rfc3296.html ManageDsaIT] LDAP control which provides a mechanism to tell the LDAP server to return referral entries as ordinary entries. Active Directory does not support this control which results in a {{{javax.naming.PartialResultException: Unprocessed Continuation Reference(s)}}} when the search results are read by the client if referrals were encountered. (Note that all other settings will not send the {{{Manage Referral}}} control.)<br/><br/>

  * to ignore the partial result exceptions you can set:
{{{
edu.vt.middleware.ldap.handlerIgnoreExceptions=javax.naming.LimitExceededException,javax.naming.PartialResultException
}}}
This will will instruct the search result handler to ignore exceptions of type {{{LimitExceededException}}} and {{{PartialResultException}}}.<br/>
However, this solution is *not* recommend as referrals and entries can be returned in any order and you may miss entries found after a referral.

=== Following Referrals ===
Set the property: _edu.vt.middleware.ldap.referral=follow_<br/>
If you are confident that all the referrals returned by the Active Directory can be followed you can use this setting. Note that referrals often contain hostnames other than the server that is being searched. The authentication credentials for the original connection must be valid for any hosts supplied by the referrals. In addition, these hostnames must be DNS resolvable and reachable in order for the search to be successful. {{{javax.naming.CommunicationException}}} and {{{java.net.UnknownHostException}}} are commonly encountered when following referrals.<br/><br/>

=== Throwing Referrals ===
Set the property: _edu.vt.middleware.ldap.referral=throw_<br/>
Using this option will result in a {{{com.sun.jndi.ldap.LdapReferralException: Continuation Reference}}} being thrown when the search results are read. However, using this option guarantees that all entries will be read before the first referral is encountered. This option exists to allow you to decide whether to follow or ignore each referral and you can do so in several ways.<br/><br/>

  * to ignore the referral exceptions you can set:
{{{
edu.vt.middleware.ldap.handlerIgnoreExceptions=javax.naming.LimitExceededException,javax.naming.ReferralException
}}}
This will will instruct the search result handler to ignore exceptions of type {{{LimitExceededException}}} and {{{ReferralException}}}.<br/> Since all the entries will be read before the first referral is encountered, this is an easy mechanism for ignoring referrals.<br/><br/>

If you would like to process each result separately and make custom decisions, you will need to implement a custom [vtldapHandlers search result handler].<br/><br/>

=== Global Catalog ===
The Global Catalog enables searching for Active Directory objects in any domain in the forest without the need for subordinate referrals.
Because the Global Catalog contains only a subset of the attributes of an object, this solution is viable only if the attributes requested for the search results are stored in the Global Catalog. (Note the GC is accessible on port 3268/3269, not the standard LDAP ports of 389/636.)

=== Conclusions ===
  * If you must follow referrals use 'follow' and work with your Active Directory administrator to ensure you have the appropriate access to follow all referrals.
  * If you can ignore referrals use 'throw' and set handlerIgnoreExceptions appropriately.
  * If you don't want to deal with referrals and your Global Catalog contains every attribute you need, use it.

=== Useful Links ===
  * [http://java.sun.com/products/jndi/tutorial/ldap/referral/jndi.html Referrals in JNDI]
  * [http://java.sun.com/products/jndi/tutorial/ldap/referral/throw.html Manually Following Referrals]

== Binary Attributes ==
Some attributes in the Active Directory may be binary and need to be declared as such when they are retrieved.<br/><br/>

To work around this issue you can set: 
{{{
edu.vt.middleware.ldap.binaryAttributes=objectSid objectGUID
}}}
This will allow you to properly retrieve these attributes as byte arrays.

== Range Attributes ==
Active Directory may not return all the values of an attribute, electing instead to provide the client with a range of attribute values. This practice is documented in an expired RFC: [http://www.tkk.fi/cc/docs/kerberos/draft-kashi-incremental-00.txt Incremental Retrieval of Multi-valued Properties]. For instance, requests for the `member` attribute may return a result like: `member;Range=0-1000`. The client is then expected to request additional attribute values of the form `member;Range=1001-2000` and so forth until all values have been retrieved.

=== !RangleSearchResultHandler ===
A [vtldapHandlers search result handler] can be used to process these attribute values.
{{{
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.naming.NamingEnumeration;
import javax.naming.NamingException;
import javax.naming.directory.Attribute;
import javax.naming.directory.Attributes;
import javax.naming.directory.BasicAttribute;
import javax.naming.directory.BasicAttributes;
import javax.naming.directory.SearchResult;

import edu.vt.middleware.ldap.Ldap;
import edu.vt.middleware.ldap.handler.CopySearchResultHandler;
import edu.vt.middleware.ldap.handler.SearchCriteria;

/**
 * The <code>RangeSearchResultHandler</code> rewrites attributes returned from Active
 * Directory to include all values.
 */
public class RangeSearchResultHandler extends CopySearchResultHandler {

  /** The string expression matching the attribute ID. */
  private static final String RANGE_PATTERN_STRING = "^(.*?);range=([\\d\\*]+)-([\\d\\*]+)";

  /** The attribute ID pattern. */
  private static final Pattern PATTERN = Pattern.compile(RANGE_PATTERN_STRING);

  /** Ldap object for searching. */
  private Ldap ldap;

  public RangeSearchResultHandler(final Ldap ldap) {
    this.ldap = ldap;
  }

  protected Attributes processAttributes(final SearchCriteria sc, final SearchResult sr) throws NamingException {
    Attributes attrs = sr.getAttributes();
    Attributes newAttrs = new BasicAttributes(attrs.isCaseIgnored());
    NamingEnumeration<? extends Attribute> en = attrs.getAll();
    while (en.hasMore()) {
      Attribute attr = en.next();

      // Match attribute ID against the pattern ?
      Matcher matcher = PATTERN.matcher(attr.getID());

      // If the attribute ID does not match the pattern, just copy the attribute
      if (!matcher.find()) {
        newAttrs.put(attr);
      } else {
        // Determine the attribute name without the range syntax
        final String attributeNameWithoutRange = matcher.group(1);
        this.logger.debug("Original attribute ID '" + attr.getID() + "' new '" + attributeNameWithoutRange + "'");

        // Create or update the attribute whose ID has the range syntax removed
        Attribute newAttr = attrs.get(attributeNameWithoutRange);
        if (newAttr == null) {
          newAttr = new BasicAttribute(attributeNameWithoutRange, attr.isOrdered());
          newAttrs.put(newAttr);
        }

        // Copy values
        NamingEnumeration<?> e = attr.getAll();
        while (e.hasMore()) {
          newAttr.add(e.next());
        }

        // If the attribute ID ends with * we're done, otherwise increment
        if (attr != null && !attr.getID().endsWith("*")) {
          // Determine next attribute ID
          int start = Integer.parseInt(matcher.group(2));
          int end = Integer.parseInt(matcher.group(3));
          int diff = end - start;
          String nextAttributeID = attributeNameWithoutRange + ";range=" + Integer.toString(end + 1) + "-"
              + Integer.toString(end + diff + 1);

          this.logger.debug("Searching for next attribute '" + nextAttributeID + "'");
          Attributes attributes = this.ldap.getAttributes(sr.getNameInNamespace(), new String[] { nextAttributeID });
          NamingEnumeration<? extends Attribute> nextEn = attributes.getAll();
          while (nextEn.hasMore()) {
            Attribute nextAttribute = nextEn.next();
            if (nextAttribute != null) {
              this.logger.debug("Searching for next attribute found '" + nextAttribute.getID() + "'");
              newAttrs.put(nextAttribute);
            }
          }

          // Include the next attribute in the search result
          sr.setAttributes(newAttrs);

          // Iterate
          newAttrs = processAttributes(sc, sr);
        }
      }
    }

    return newAttrs;
  }
}
}}}

_Thanks to Tom Zeller @ Memphis for this implemenation_

=== Useful Links ===
  * [http://www.openldap.org/its/index.cgi?findid=5472]
  * [http://www.openldap.org/lists/ietf-ldapbis/200404/msg00047.html]
  * [http://www.openldap.org/lists/openldap-bugs/200406/msg00108.html]